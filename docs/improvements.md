# Efficient Non-ML Table Detection in Spreadsheets

## Overview
Table detection in spreadsheets involves locating all distinct tables within a worksheet and determining their cell ranges. Unlike approaches that use machine learning (ML) models (which require training data), non-ML methods rely on **clustering algorithms, rules, and heuristics** to identify table structures. These traditional techniques leverage patterns in the spreadsheet’s content and layout – such as contiguous cell regions, formatting cues, and empty rows/columns – to infer where tables begin and end. Non-ML methods are attractive for their **speed and simplicity**, as they typically run in linear time relative to the number of cells and do not need a training phase. However, detecting tables in spreadsheets is challenging because real-world sheets often contain multiple tables with diverse layouts, irregular spacing, or decorative formatting that can obscure table boundaries ([TableSense: Spreadsheet Table Detection with Convolutional Neural Networks](https://www.microsoft.com/en-us/research/uploads/prod/2019/01/TableSense_AAAI19.pdf#:~:text=different,of%20complicated%20table%20structures%20and)). In the following sections, we outline existing non-ML algorithms, discuss clustering and rule-based techniques, compare their effectiveness, and recommend strategies for optimizing performance in practical scenarios.

## Existing Non-ML Table Detection Methods
Over the years, researchers and practitioners have developed several non-ML algorithms for table detection in spreadsheets. These methods range from simple region-growing approaches (as used in tools like Microsoft Excel) to more sophisticated graph-based algorithms. Below we summarize a few notable techniques and their effectiveness:

- **Region-Growing Heuristic:** Commodity spreadsheet software often uses a simple region-growing technique to find a table starting from a given cell ([](https://arxiv.org/pdf/2106.13500#:~:text=%E2%80%A2%20Region,area%20to%20include%20non%02blank%20neighboring)). For example, Excel’s built-in *Ctrl+* (Ctrl + Asterisk) function expands from a selected cell outward to include all contiguous non-empty neighboring cells (using 8-directional connectivity) ([](https://arxiv.org/pdf/2106.13500#:~:text=%E2%80%A2%20Region,area%20to%20include%20non%02blank%20neighboring)). The result is treated as a detected table range. This approach is **fast and works well for clean, isolated tables**, as it essentially performs a flood-fill of adjacent filled cells. However, region-growing is **fragile for complex layouts** ([TableSense: Spreadsheet Table Detection with Convolutional Neural Networks](https://www.microsoft.com/en-us/research/uploads/prod/2019/01/TableSense_AAAI19.pdf#:~:text=while%20region,are%20properly%20nor%02malized%20for%20automated)). If a sheet has multiple tables or irregular structures (e.g. tables separated by only a single blank line, or tables with internal empty cells), a naive region-growing often merges or misses tables. A study found that a basic region-growth algorithm achieved only about *58.5% recall and 55.2% precision* on a multi-table spreadsheet corpus ([](https://arxiv.org/pdf/2106.13500#:~:text=one,Spreadsheet%20table%20detection%20on%20WebSheet400)) – indicating it failed on many complex cases. Extensions like multi-stride region growing with post-processing can improve accuracy slightly (e.g. using an SVM classifier to verify table ranges ([](https://arxiv.org/pdf/2106.13500#:~:text=match%20at%20L803%20%E2%80%A2%20Region,to%20a%20true%20table%20region))), but fundamentally this approach struggles with heterogeneous layouts ([TableSense: Spreadsheet Table Detection with Convolutional Neural Networks](https://www.microsoft.com/en-us/research/uploads/prod/2019/01/TableSense_AAAI19.pdf#:~:text=different,of%20complicated%20table%20structures%20and)).

- **Rule-Based Detection (Early Methods):** Prior to modern ML solutions, researchers explored purely rule-based algorithms for spreadsheets. **Doush and Pontelli (2010)** developed one of the early rule-based table recognition methods for spreadsheets ([Detecting and recognizing tables in spreadsheets - ResearchGate](https://www.researchgate.net/publication/220932993_Detecting_and_recognizing_tables_in_spreadsheets#:~:text=ResearchGate%20www,still%20a%20big%20gap)). Their approach relied on heuristics to identify table regions, such as detecting blocks of filled cells and using layout cues to separate tables. While their method proved that rule-based detection is feasible, it was reported that there remained “a big gap” in accuracy compared to the needs of real-world use ([Detecting and recognizing tables in spreadsheets - ResearchGate](https://www.researchgate.net/publication/220932993_Detecting_and_recognizing_tables_in_spreadsheets#:~:text=ResearchGate%20www,still%20a%20big%20gap)). In practice, simple rule sets can reliably detect obvious tables (especially those delimited by empty rows/columns), but may falter on edge cases – for example, distinguishing a table’s header from a title, or handling tables that share a contiguous area.

- **Graph-Based Algorithms:** More advanced non-ML techniques model the spreadsheet as a graph to capture spatial relationships between cells. **Koci et al. (2018)** introduced a graph representation of spreadsheet layout and a rule-driven algorithm called **“Remove and Conquer (RAC)”** to recognize tables ([Algorithms for Table Structure Recognition](https://ingenius.ups.edu.ec/index.php/ingenius/article/view/25.2021.05/4241#:~:text=2,direction%20of%20the%20graph%20that)) ([[2211.08469] Deep learning for table detection and structure recognition: A survey](https://ar5iv.labs.arxiv.org/html/2211.08469#:~:text=E%20Koci%20,set%20of%20carefully%20selected%20criteria)). In their approach, each non-empty cell is first assigned a **layout role** (e.g. *Header*, *Data*, *Title*, etc.), based on cell features or heuristics. Adjacent cells with the same role are grouped into regions, and a graph is constructed where nodes represent these regions and edges represent spatial adjacency ([Algorithms for Table Structure Recognition](https://ingenius.ups.edu.ec/index.php/ingenius/article/view/25.2021.05/4241#:~:text=It%20also%20is%20inferred%20the,En%02cabezado%2C%20Datos%2C%20T%C3%ADtulo)) ([Algorithms for Table Structure Recognition](https://ingenius.ups.edu.ec/index.php/ingenius/article/view/25.2021.05/4241#:~:text=%29%206%3D%201,column%2C%20and%20maximum%20column%20match)). The RAC algorithm then iteratively partitions this graph to isolate table structures using a set of curated rules ([Algorithms for Table Structure Recognition](https://ingenius.ups.edu.ec/index.php/ingenius/article/view/25.2021.05/4241#:~:text=2,direction%20of%20the%20graph%20that)). Notably, RAC’s rules aren’t limited to immediate neighbors; they consider broader context in the sheet (for instance, ensuring that header regions align with data regions below them, and separating far-apart regions into different tables) ([[PDF] Layout Inference and Table Detection in Spreadsheet Documents](https://upcommons.upc.edu/bitstream/handle/2117/328195/TEK1de1.pdf#:~:text=Documents%20upcommons,In%20other)). This method achieved significantly better detection on complex sheets than simpler heuristics ([Rule-based spreadsheet data transformation from arbitrary to ...](https://www.semanticscholar.org/paper/Rule-based-spreadsheet-data-transformation-from-to-Shigarov-Mikhailov/19cefa45c8975634b9cf6fa82b745dcc79b4b9ae#:~:text=This%20paper%20proposes%20Remove%20and,rules%20that%20achieves%20significant)). In cases where rule-based graph partitioning struggled, Koci et al. even experimented with a **genetic algorithm** to optimize the graph cut and improve table separation ([[2211.08469] Deep learning for table detection and structure recognition: A survey](https://ar5iv.labs.arxiv.org/html/2211.08469#:~:text=P%20Riba%20,to%20tables%20in%20the%20sheet)) – still without supervised learning. Graph-based methods like RAC demonstrate that with comprehensive rules, non-ML approaches can handle fairly complex layouts (e.g. nested tables or tables with multi-level headers) by analyzing connectivity and alignment.

- **Pattern-Based Table Discovery:** Another line of work focuses on identifying tables by the **consistency patterns** in rows and columns. One prominent example is **Pytheas (Christodoulakis et al. 2020)**, a tool for discovering tables in loosely-structured CSV files (which are essentially spreadsheets without rich formatting). Pytheas uses a *fuzzy rule-based system* to classify each line in a file as part of a table or not, leveraging the intuition that “tables maintain a coherency of values in each column” ([GitHub - cchristodoulaki/Pytheas: Pattern-based table discovery in Open Data CSV files](https://github.com/cchristodoulaki/Pytheas#:~:text=extracting%20tables%20from%20CSV%20files,art%20approaches%20shows%20that)). Its rules evaluate features like: does a column contain values of a uniform type or format (e.g. mostly numeric vs mostly text), do consecutive rows share a similar structure (number of columns, patterns of capitalization), and are there keywords (like "Total" or "Table") indicating boundaries ([](http://www.vldb.org/pvldb/vol13/p2075-christodoulakis.pdf#:~:text=effect%20of%20different%20rules,when%20removed%2C%20ta%02ble%20discovery%20dropped)) ([Heuristic Algorithm for Automatic Extraction Relational Data from Spreadsheet Hierarchical Tables](https://thesai.org/Downloads/Volume12No10/Paper_82-Heuristic_Algorithm_for_Automatic_Extraction_Relational_Data.pdf#:~:text=heuristic%20rules%20and%20cell%20features,Extract%20Table%20Name)). By combining multiple heuristics with a weighting scheme, Pytheas can robustly identify header lines and data regions even if the file contains stray text or multiple tables. Impressively, this rule-based approach achieved **over 95% precision and recall** in detecting tables across thousands of real-world files ([GitHub - cchristodoulaki/Pytheas: Pattern-based table discovery in Open Data CSV files](https://github.com/cchristodoulaki/Pytheas#:~:text=Australian%20portals,for%20accurately%20identifying%20potential%20errors)), outperforming earlier heuristics and even some ML-based methods on the same datasets. This illustrates that a carefully designed set of rules (with possible fine-tuning) can rival machine learning in accuracy, while remaining efficient.

In summary, non-ML table detection methods range from **simple clustering of filled cells** to **complex heuristic frameworks**. They generally run quickly (linear or near-linear in the number of cells/rows) and work well when tables adhere to expected patterns. However, their effectiveness depends on how well the chosen rules handle the variety in layout. Next, we delve deeper into the clustering and rule techniques that underpin these methods.

## Clustering Techniques for Table Segmentation
Clustering-based approaches attempt to **group spreadsheet cells into table regions** based on spatial proximity or layout similarity, without learning from examples. In spreadsheets, clustering often equates to finding contiguous blocks of non-empty cells (connected-component labeling in the grid) or partitioning the sheet’s cells by detecting separators. Key clustering strategies include:

- **Connected Region Detection:** The most straightforward segmentation is to treat the spreadsheet as a matrix and identify clusters of populated cells that are adjacent to each other. Adjacent can be defined in terms of sharing a common border (above, below, left, right) – effectively 4-neighborhood or 8-neighborhood connectivity. This approach scans the sheet from the top-left to bottom-right and marks where continuous runs of filled cells occur, stopping when an empty row or column breaks the run ([Algorithms for Table Structure Recognition](https://ingenius.ups.edu.ec/index.php/ingenius/article/view/25.2021.05/4241#:~:text=Region%20detection%20consists%20in%20scanning,maximal%20collection%20R%20%E2%8A%86%20W)). Each maximal rectangular block of filled cells can be labeled a candidate table region ([Algorithms for Table Structure Recognition](https://ingenius.ups.edu.ec/index.php/ingenius/article/view/25.2021.05/4241#:~:text=Region%20detection%20consists%20in%20scanning,maximal%20collection%20R%20%E2%8A%86%20W)). In practice, this yields a set of regions $R_1, R_2, …$, each presumably corresponding to a table. This clustering by continuity is very fast and works especially well if tables are separated by **empty rows/columns**, which act as natural dividers. Many rule-based algorithms start with an initial segmentation like this, and then refine it. For example, one heuristic method defines a *“region”* as any maximal rectangular group of non-empty cells, then later decides which regions are true tables versus ancillary content ([Algorithms for Table Structure Recognition](https://ingenius.ups.edu.ec/index.php/ingenius/article/view/25.2021.05/4241#:~:text=A%20region%20is%20defined%20as,role%20is%20defined%20as%20following)) ([Algorithms for Table Structure Recognition](https://ingenius.ups.edu.ec/index.php/ingenius/article/view/25.2021.05/4241#:~:text=%29%206%3D%201,column%2C%20and%20maximum%20column%20match)). The connected region approach will correctly isolate tables in a sheet where, say, a blank row always exists between tables (or a blank column between side-by-side tables). It can struggle if tables are **not** cleanly separated by empties – in such cases, additional logic is needed to avoid merging distinct tables into one cluster.

- **Spatial Distance Clustering:** In scenarios where tables are close together or contain internal gaps, simple connectivity might fail. More flexible clustering can be done by treating each filled cell as a point with coordinates (row, column) and using algorithms like DBSCAN or hierarchical clustering based on distances. The idea is to cluster cells that lie near each other and have similar spacing, even if not directly contiguous. For instance, if two groups of cells are separated by a small gap of a few empty cells, a distance-based clustering could still identify them as separate clusters if the gap exceeds a threshold. In practice, this approach is less common for spreadsheets because the grid structure provides clearer segmenting cues (empty lines) than arbitrary Euclidean distance. However, it has been explored in document image analysis. For example, treating cell bounding boxes and using clustering can help detect tables in a page layout by grouping text blocks that form a table. In spreadsheets, one might use a rule like “if there is more than N empty rows between filled cells, consider them separate clusters (tables)”. This is essentially a thresholded distance in the vertical direction. Such clustering can also account for side-by-side tables: a certain number of consecutive empty columns could signal a split into two clusters horizontally ([Heuristic Algorithm for Automatic Extraction Relational Data from Spreadsheet Hierarchical Tables](https://thesai.org/Downloads/Volume12No10/Paper_82-Heuristic_Algorithm_for_Automatic_Extraction_Relational_Data.pdf#:~:text=B,filled%20data%20columns%2C%20that%20means)) ([Heuristic Algorithm for Automatic Extraction Relational Data from Spreadsheet Hierarchical Tables](https://thesai.org/Downloads/Volume12No10/Paper_82-Heuristic_Algorithm_for_Automatic_Extraction_Relational_Data.pdf#:~:text=V,to%20explore%20the%20new%20one)).

- **Graph Partitioning:** A more advanced clustering technique represents cells (or cell groups) as nodes in a graph and draws edges based on neighbor relationships, then **partitions the graph** to delineate tables. The Remove-and-Conquer (RAC) algorithm mentioned earlier is a prime example. After building a graph of cell regions with edges linking adjacent regions, RAC separates the graph into subgraphs, each subgraph corresponding to a table ([Algorithms for Table Structure Recognition](https://ingenius.ups.edu.ec/index.php/ingenius/article/view/25.2021.05/4241#:~:text=2,direction%20of%20the%20graph%20that)). Clustering here is achieved by **iteratively removing “bridge” edges** that connect what appear to be different tables. For instance, RAC looks at the topology of the graph – edges that span large gaps or connect header nodes far apart might be cut first ([Algorithms for Table Structure Recognition](https://ingenius.ups.edu.ec/index.php/ingenius/article/view/25.2021.05/4241#:~:text=2,direction%20of%20the%20graph%20that)). The algorithm uses a list of criteria (rules) to decide which edges to remove so that the remaining connected components of the graph represent individual tables. This can be seen as clustering with domain knowledge: instead of a generic distance, the graph-partition rules consider things like alignment of headers and data types. Another work in this vein used genetic algorithms to optimally partition the spreadsheet cell graph, effectively clustering cells into the best table groups by maximizing an objective function (e.g., internal consistency of each group) ([[2211.08469] Deep learning for table detection and structure recognition: A survey](https://ar5iv.labs.arxiv.org/html/2211.08469#:~:text=P%20Riba%20,to%20tables%20in%20the%20sheet)). Graph-based clustering is powerful – it can handle cases like tables that are adjacent but with clearly different header labels or formatting, by learning those distinctions in the graph model. The trade-off is that it’s more complex to implement and may have a slightly higher computational cost than a simple region scan (though still efficient for typical sheet sizes).

In summary, clustering techniques for table segmentation break the sheet into candidate table regions **without any training data**. They primarily use spatial cues: contiguity (connected components) and separation (empty space or large distance) are key signals. These clustering steps often serve as the first phase of a detection pipeline, to propose table areas which can then be verified or refined by heuristic rules.

## Rule-Based Heuristic Methods for Table Identification
Rule-based methods build on the initial clusters or directly scan the sheet to decide which areas are tables and delineate their structure. These approaches use human-defined heuristics – if-then rules – derived from typical characteristics of spreadsheet tables. Some common and effective heuristics include:

- **Empty Lines and Separators:** Perhaps the most basic rule is that *empty rows or columns signify a break* between tables ([Heuristic Algorithm for Automatic Extraction Relational Data from Spreadsheet Hierarchical Tables](https://thesai.org/Downloads/Volume12No10/Paper_82-Heuristic_Algorithm_for_Automatic_Extraction_Relational_Data.pdf#:~:text=B,filled%20data%20columns%2C%20that%20means)) ([Heuristic Algorithm for Automatic Extraction Relational Data from Spreadsheet Hierarchical Tables](https://thesai.org/Downloads/Volume12No10/Paper_82-Heuristic_Algorithm_for_Automatic_Extraction_Relational_Data.pdf#:~:text=V,to%20explore%20the%20new%20one)). A rule-based system will often treat any completely blank row as a boundary: everything above it and below the previous boundary is one table. Similarly, a blank column indicates that content to its left and right belong to different tables (if they align in the same rows). This simple rule works well for many well-organized sheets and is computationally trivial to apply (just check each row/col for emptiness). Many algorithms start by splitting tables on blank lines ([Heuristic Algorithm for Automatic Extraction Relational Data from Spreadsheet Hierarchical Tables](https://thesai.org/Downloads/Volume12No10/Paper_82-Heuristic_Algorithm_for_Automatic_Extraction_Relational_Data.pdf#:~:text=B,filled%20data%20columns%2C%20that%20means)). For example, one heuristic extraction method explicitly checks for multiple tables by looking for an empty row before the end of the data range – if found, it concludes a table ended and another may begin below ([Heuristic Algorithm for Automatic Extraction Relational Data from Spreadsheet Hierarchical Tables](https://thesai.org/Downloads/Volume12No10/Paper_82-Heuristic_Algorithm_for_Automatic_Extraction_Relational_Data.pdf#:~:text=In%20this%20case%2C%20if%20the,to%20explore%20the%20new%20one)). However, designers of these systems must also handle exceptions: sometimes users leave an empty row **inside** a table for readability (which should **not** split the table). Advanced rules account for context, e.g. if the rows above and below a single empty row have very similar column structures, it might be a deliberate spacer *within* one table rather than a separator between two tables.

- **Header Detection Rules:** Distinguishing header rows (column titles) from data rows is crucial for identifying table structure. Rule-based systems use a variety of cues to detect headers:
    - **Formatting**: Headers are often visually distinguished – e.g. bold text, background shading, or a different font. A rule might say “if a row of cells is bold and the next row is not, the bold row is likely a header.” Cell border styles can also indicate headers (a thick bottom border might underline a header row). In spreadsheets, examining cell style metadata (font weight, fill color, border lines) can greatly aid table inference ([Algorithms for Table Structure Recognition](https://ingenius.ups.edu.ec/index.php/ingenius/article/view/25.2021.05/4241#:~:text=2.1.1.%20A%20Rule,top%2C%20bottom%2C%20left%2C%20and%20right)) ([Algorithms for Table Structure Recognition](https://ingenius.ups.edu.ec/index.php/ingenius/article/view/25.2021.05/4241#:~:text=A%20cell%20format%20is%20the,of%20columns%2C%20computed%20as%20the)). One approach is to group cells by similar formatting and treat a change in style as a boundary ([Algorithms for Table Structure Recognition](https://ingenius.ups.edu.ec/index.php/ingenius/article/view/25.2021.05/4241#:~:text=Region%20detection%20consists%20in%20scanning,maximal%20collection%20R%20%E2%8A%86%20W)) (for instance, if a block of cells with one format is followed by differently formatted cells, that could mark the header/body division).
    - **Content Patterns**: Headers usually contain text labels, whereas data rows often contain numeric values (or consistent data types in each column). A heuristic can check the first non-empty row of a region: if most cells in that row are text (and the cells below are numeric), then that row is a header. Additionally, headers often use certain keywords or patterns (e.g., they may include units or aggregations like “Total”, “Avg”). A study on heuristic table extraction noted checking for keywords like "ID", "Name", or "Total" in a row to classify it as a header or a title line ([Heuristic Algorithm for Automatic Extraction Relational Data from Spreadsheet Hierarchical Tables](https://thesai.org/Downloads/Volume12No10/Paper_82-Heuristic_Algorithm_for_Automatic_Extraction_Relational_Data.pdf#:~:text=heuristic%20rules%20and%20cell%20features,Extract%20Table%20Name)) ([Heuristic Algorithm for Automatic Extraction Relational Data from Spreadsheet Hierarchical Tables](https://thesai.org/Downloads/Volume12No10/Paper_82-Heuristic_Algorithm_for_Automatic_Extraction_Relational_Data.pdf#:~:text=1,Table)).
    - **Position and Span**: In many tables, the top rows of a cluster of cells are headers. If a table region has relatively consistent columns of data below, the first one or two rows could be headers (sometimes multi-level headers). Rules can be iterative: assume the first row is header and see if the data below is homogeneous; if not, maybe the first two rows form a compound header. Merged cells in top rows are also a hint – e.g. a merged cell spanning several columns in the first row often indicates a table title or a group header for multiple column sub-sections. A heuristic could detect merged regions at the top of a block and mark them as header information ([Heuristic Algorithm for Automatic Extraction Relational Data from Spreadsheet Hierarchical Tables](https://thesai.org/Downloads/Volume12No10/Paper_82-Heuristic_Algorithm_for_Automatic_Extraction_Relational_Data.pdf#:~:text=2,return%20address%20of%20merged%20region)) ([Heuristic Algorithm for Automatic Extraction Relational Data from Spreadsheet Hierarchical Tables](https://thesai.org/Downloads/Volume12No10/Paper_82-Heuristic_Algorithm_for_Automatic_Extraction_Relational_Data.pdf#:~:text=8,Extract%20Top%20Attributes)).

- **Table Name and Title Identification:** Some spreadsheets have a named title for a table (often a cell saying “Table 1: Sales Data” above the actual data). Heuristics can be devised to capture this:
    - If a single cell text is found above a table and contains the word "Table" or is stylized as a title (e.g. bold, larger font), it might be tagged as the table’s name or caption ([Heuristic Algorithm for Automatic Extraction Relational Data from Spreadsheet Hierarchical Tables](https://thesai.org/Downloads/Volume12No10/Paper_82-Heuristic_Algorithm_for_Automatic_Extraction_Relational_Data.pdf#:~:text=heuristic%20rules%20and%20cell%20features,Extract%20Table%20Name)). One algorithm specifically checks if a stand-alone cell contains the substring "Table" and is followed by an empty row – if yes, it marks it as a table name line ([Heuristic Algorithm for Automatic Extraction Relational Data from Spreadsheet Hierarchical Tables](https://thesai.org/Downloads/Volume12No10/Paper_82-Heuristic_Algorithm_for_Automatic_Extraction_Relational_Data.pdf#:~:text=heuristic%20rules%20and%20cell%20features,Extract%20Table%20Name)). This helps in not only detecting the table, but also extracting its descriptive name.
    - Titles might not use the word "Table" explicitly. Another clue: a title is usually separated by an empty row from the table below (or some whitespace). So a rule might say “a lone text line followed by a blank line, then a dense block of cells = title + table”.
    - While title detection isn’t strictly necessary for delineating the table range, it can prevent confusion (ensuring that title cell is not mistaken as a part of the table’s header).

- **Consistency and Shape Heuristics:** A fundamental property of tables is that *data rows are uniform*. Many heuristic approaches enforce that once a header is identified, the subsequent rows consistently have the same number of columns (or fill the same set of columns). If a row breaks the pattern – e.g., suddenly has fewer cells or different alignment – it might indicate the end of the table or a new section. Pytheas’s rule set, for instance, gives weight to **structure consistency** down columns ([](http://www.vldb.org/pvldb/vol13/p2075-christodoulakis.pdf#:~:text=%28see%20Table%203%29,49%20percentage%20points%20respec%02all%20rules)). If removing a certain rule (e.g. the rule that “each column should have a consistent type or format down the table”) caused a big drop in performance, indicating the importance of that heuristic ([](http://www.vldb.org/pvldb/vol13/p2075-christodoulakis.pdf#:~:text=%28see%20Table%203%29,49%20percentage%20points%20respec%02all%20rules)). Similarly, a heuristic might check for column **case consistency** (e.g., header labels often follow a capitalization style different from data entries) – such rules help differentiate header vs data ([](http://www.vldb.org/pvldb/vol13/p2075-christodoulakis.pdf#:~:text=%28see%20Table%203%29,49%20percentage%20points%20respec%02all%20rules)). Another example: if a purported table has a row that is mostly empty while the following row has data again, some algorithms might infer that the empty row was just a spacer and continue the same table, whereas others might split there. The decision can be encoded as a rule that considers how many “almost empty” rows in the middle of a region can be tolerated before concluding the table ended.

- **Use of Borders and Lines:** Spreadsheets allow users to draw border lines around their tables. A heuristic method can exploit this by checking cell border attributes ([Algorithms for Table Structure Recognition](https://ingenius.ups.edu.ec/index.php/ingenius/article/view/25.2021.05/4241#:~:text=2.1.1.%20A%20Rule,top%2C%20bottom%2C%20left%2C%20and%20right)) ([Algorithms for Table Structure Recognition](https://ingenius.ups.edu.ec/index.php/ingenius/article/view/25.2021.05/4241#:~:text=attributes%2C%20such%20as%20border%2C%20format%2C,the%20visual%20formatting%20applied%20to)). For instance, if a contiguous range of cells is enclosed by thick borders (and outside those borders cells are empty or differently bordered), the algorithm can directly treat that range as a table. Borders essentially provide a strong visual cluster signal. Not all tables have explicit drawn borders, but when present they can be a shortcut to detection. Some rule-based systems give precedence to bordered ranges – detecting them first as tables – and then only use weaker cues for the remaining areas.

All these rules are applied in combination to accurately identify tables. A robust system might apply rules in a sequence or in parallel and use a scoring mechanism. For example, a candidate region of cells might be scored on various heuristic checks (format consistency, presence of a header row, etc.) and only declared a table if it meets certain criteria or thresholds on those scores. Because these heuristics are manually defined, they require expert knowledge and thorough testing on diverse sheets to cover edge cases. Nonetheless, when well-designed, they can achieve high accuracy. As noted, Pytheas’s fuzzy rule approach reached over 95% accuracy on open data files ([GitHub - cchristodoulaki/Pytheas: Pattern-based table discovery in Open Data CSV files](https://github.com/cchristodoulaki/Pytheas#:~:text=Australian%20portals,for%20accurately%20identifying%20potential%20errors)), and other heuristic methods report reliably detecting clearly separated tables with simple rules ([AN INTERACTIVE TOOL FOR EXTRACTING LOW-QUALITY ...](https://www.researchgate.net/publication/349252784_AN_INTERACTIVE_TOOL_FOR_EXTRACTING_LOW-QUALITY_SPREADSHEET_TABLES_AND_CONVERTING_INTO_RELATIONAL_DATABASE#:~:text=AN%20INTERACTIVE%20TOOL%20FOR%20EXTRACTING,list%20of%20carefully%20curated)). The advantage is that these rules are **interpretable** – one can understand why the algorithm made a decision – and adjustable if needed for a specific application or domain (e.g. one could add a custom rule if all spreadsheets in a company follow a particular pattern).

## Performance Optimization Strategies
Non-ML table detection methods are generally efficient, but real-world use may involve thousands of spreadsheets or very large sheets, so performance optimization is important. Here are strategies and considerations to ensure these techniques run fast in practice:

- **Linear Scanning and Early Stopping:** Most rule-based algorithms already operate in linear time relative to the number of cells (or rows) by scanning through the sheet. We can optimize by restricting the scan to the **used range** of the sheet – i.e., from the first to last non-empty cell. Modern spreadsheet APIs (like Excel’s OpenXML or Python’s openpyxl) can give the index of the last used row and column; using this to limit iteration avoids checking a million rows needlessly if only the first 100 are in use ([Heuristic Algorithm for Automatic Extraction Relational Data from Spreadsheet Hierarchical Tables](https://thesai.org/Downloads/Volume12No10/Paper_82-Heuristic_Algorithm_for_Automatic_Extraction_Relational_Data.pdf#:~:text=for%20,Iterate%20on%20all%20rows)) ([Heuristic Algorithm for Automatic Extraction Relational Data from Spreadsheet Hierarchical Tables](https://thesai.org/Downloads/Volume12No10/Paper_82-Heuristic_Algorithm_for_Automatic_Extraction_Relational_Data.pdf#:~:text=6,Table%20Detection%20Process)). Additionally, once a table is detected and its range determined, the algorithm can skip over those cells when continuing the scan for subsequent tables. This prevents re-processing cells and can short-circuit the search if, for example, the bottom of the sheet is reached. In practice, a well-implemented region detection can find all tables in a sheet with a single pass or a small constant number of passes over the data.

- **Efficient Data Structures:** Using appropriate data structures can speed up rule evaluations. For instance, to check if a row is empty, one can maintain an array of row occupancy counts (populated during the initial scan) rather than checking each cell in that row repeatedly. Similarly, one can precompute column data types – e.g., mark each column with flags if it contains only numeric values or only text in a given region. This makes applying consistency rules faster since you don’t have to iterate through all cells in a column each time; you already know the column’s overall type pattern. Caching formatting information (like having sets of rows that are bold, or columns that have borders) can also allow constant-time checks for those rules. Essentially, a bit of upfront precomputation (still linear) can make subsequent rule checks nearly O(1) for each row/col.

- **Clustering First, Rules Second:** A common performance strategy is to **cluster (segment) first**, then apply costly rules only within those clusters. For example, first do a quick pass to identify contiguous filled regions as candidate tables. If a sheet has, say, 10 distinct regions of data separated by empties, the subsequent analysis (header identification, etc.) can be confined to each region individually. This reduces the problem size for the rule-based analysis phases. It also lends itself to parallelization – each region (table candidate) can be analyzed on a separate thread or process, since tables on the same sheet are independent in terms of detection. By contrast, a naive approach that checks every possible subarea of the sheet for “table-like” properties would be far less efficient. Thus, **divide-and-conquer** based on clustering improves speed and scalability.

- **Heuristic Shortcuts:** Some simple checks can avoid heavier processing. For instance, if a region of cells is extremely large (hundreds of columns or thousands of rows) but contains no obvious header (no text in the first row, or no bold formatting), a rule-based system might decide this is likely not a well-structured table (or it may rely on external definition). Conversely, very small clusters (e.g. a 2×2 block) might be ignored as incidental data unless certain conditions are met (like specific keywords). Defining thresholds (min/max table size) helps by not over-analyzing areas that are unlikely to be legitimate tables. Another optimization is to treat *known table-like patterns* specially: for example, if the sheet is an exported database table, it will have a single header row and consistent columns – one could quickly detect that pattern and bypass more complex logic.

- **Memory and I/O Considerations:** When processing many spreadsheets, reading the file itself can be a bottleneck. Using a streaming API that reads one row at a time (and immediately applies detection logic) can be more memory-efficient than loading the entire sheet into memory. If using Python, libraries like `csv` (for CSV files) allow streaming line by line, and for Excel, libraries like `openpyxl` or `xlrd` can iterate rows. This way, the algorithm can potentially stop reading further once all tables have been found (for example, if it detects the last used row of the last table and then sees only empties, it could break out). Although in most cases you do need to read the whole used range, streaming ensures you don't hold the whole dataset in memory unnecessarily. Moreover, by interleaving I/O and processing, you hide some of the latency (processing earlier rows while later ones are being read).

- **Benchmarking and Refinement:** It’s good practice to benchmark the detection on typical and worst-case sheets. Worst-case might be a sheet that is completely filled with data (no empty separators at all) – the algorithm should handle this (it would treat the entire sheet as one table, which is correct in that scenario) and still run quickly. Optimizations like those above should ensure even a full 1,000,000-row sheet is scanned with minimal overhead. In one report, a trained ML model took ~72ms on average to detect tables in a sheet ([](https://arxiv.org/pdf/2106.13500#:~:text=Figure%204%20shows%20the%20accuracy,72ms%20for%20testing%20each%20sheet)); a pure heuristic method can be even faster since it’s doing simpler operations. For example, Pytheas processes files with an overhead of about 0.021 seconds per column per 1000 lines ([](http://www.vldb.org/pvldb/vol13/p2075-christodoulakis.pdf#:~:text=Inference%3A%20Figure%2011%20shows%20that,grouped%20similar%20rules%20based%20on)) (linear scaling), and its runtime was linear with file size ([](http://www.vldb.org/pvldb/vol13/p2075-christodoulakis.pdf#:~:text=Inference%3A%20Figure%2011%20shows%20that,grouped%20similar%20rules%20based%20on)). Such linear scalability means performance remains practical as data grows.

In essence, non-ML methods already have a performance edge due to their simplicity; careful coding (avoiding superfluous nested loops, re-using computed info) and logical short-cuts ensure they meet real-world speed and memory requirements. This makes them well-suited for high-throughput scenarios or integration into interactive tools where a user expects near-instant table recognition.

## Open-Source Tools and Libraries
Several tools and libraries implement the above techniques (or similar ones) for table detection without heavy ML, making them accessible for practical use:

- **Pytheas (Python library)** – The rule-based table discovery approach for CSV files by Christodoulakis et al. is available as open-source code ([GitHub - cchristodoulaki/Pytheas: Pattern-based table discovery in Open Data CSV files](https://github.com/cchristodoulaki/Pytheas#:~:text=Pytheas%3A%20Pattern,CSV%20Files)) ([GitHub - cchristodoulaki/Pytheas: Pattern-based table discovery in Open Data CSV files](https://github.com/cchristodoulaki/Pytheas#:~:text=extracting%20tables%20from%20CSV%20files,art%20approaches%20shows%20that)). Users can leverage Pytheas to detect tables in messy CSV or text data using its built-in rule set, or even tweak the rules for their domain. It provides an example of a fuzzy rule engine that can be studied and adapted for spreadsheets. Although CSV lacks rich formatting, Pytheas’s core idea of using column value coherency and line classification is applicable to spreadsheets as well. *(GitHub: `cchristodoulaki/Pytheas`)*.

- **Excel’s Object Model** – While not an open-source library, it’s worth noting that Excel itself exposes a `ListObjects` collection and methods to infer tables. If a spreadsheet actually uses Excel’s “Format as Table” feature, those tables can be read directly (but here we focus on detecting tables that aren’t explicitly marked). For custom detection, one can use VBA or Office scripts to replicate region-growing: e.g., starting from cell A1 and using Excel’s `CurrentRegion` property which implements the region-growing heuristic. This is essentially using Excel’s native non-ML detection (which is region based) within code. For developers wanting a quick solution inside Excel, this is a viable route. However, it won’t handle complex layouts beyond what the basic region growth can do (and as noted, that can miss tables ([TableSense: Spreadsheet Table Detection with Convolutional Neural Networks](https://www.microsoft.com/en-us/research/uploads/prod/2019/01/TableSense_AAAI19.pdf#:~:text=while%20region,are%20properly%20nor%02malized%20for%20automated))).

- **Tabula/Camelot (for PDFs)** – These are PDF table extraction tools that rely on rule-based detection of lines and spaces, not on ML. While not for spreadsheets, they demonstrate the effectiveness of heuristics in table detection: Camelot, for example, clusters text boxes by analyzing gaps between lines to find table cell structures. If one needs to detect tables in spreadsheet *images* or printed sheets, similar logic can be applied (e.g., using OpenCV to find grid lines). The reason to mention these is to highlight that across different formats (PDF, images, HTML), many successful table detection tools use rules (like detecting ruling lines or consistent text alignment). These tools are open-source and can inspire spreadsheet table detection rules as well (for instance, the idea of looking for regularly aligned text columns in a spreadsheet could be borrowed from PDF heuristics).

- **Custom Scripts and Libraries** – There are various smaller projects on GitHub aiming to detect tables in raw data. For example, some data cleaning libraries include functions to identify table-like structures in Excel/CSV. While not all are famous, a developer community often shares scripts to, say, detect the range of a table by looking for top-left and bottom-right cell coordinates that contain data. In Java, libraries like Apache POI or OpenCSV can be used to implement such detection (though they don’t have it built-in, they provide the primitives to scan cells). The academic tool **TIRS** (Topology-based Table Recognition in Spreadsheets) combined a cell classifier with layout rules ([](http://www.vldb.org/pvldb/vol13/p2075-christodoulakis.pdf#:~:text=classify%20cells%20,from%20CSV%20files%20and%20used)), though the classifier part was ML, the idea of topological rules was implemented in code. If one avoids the classifier, TIRS essentially becomes a rule-based system that could potentially be re-used.

- **Community Contributions:** As of writing, there isn’t a widely adopted standalone “table detection” library purely heuristic aside from research prototypes. Many practitioners implement their own logic as needed. The pseudo-code given in some research papers (like the algorithm in Escalona et al. 2021 ([Heuristic Algorithm for Automatic Extraction Relational Data from Spreadsheet Hierarchical Tables](https://thesai.org/Downloads/Volume12No10/Paper_82-Heuristic_Algorithm_for_Automatic_Extraction_Relational_Data.pdf#:~:text=In%20this%20case%2C%20if%20the,to%20explore%20the%20new%20one)) ([Heuristic Algorithm for Automatic Extraction Relational Data from Spreadsheet Hierarchical Tables](https://thesai.org/Downloads/Volume12No10/Paper_82-Heuristic_Algorithm_for_Automatic_Extraction_Relational_Data.pdf#:~:text=In%20this%20case%2C%20if%20the,to%20explore%20the%20new%20one)) for splitting multiple tables) can serve as a blueprint for coding your own solution. Since these methods are not complex, open-source reimplementations are feasible. We recommend checking academic code repositories or supplementary material (some papers release their code or datasets which include implementation details).

In summary, while a few open-source solutions exist (Pytheas being a notable one for CSV), one may end up writing custom code using the described techniques for a specific application. The benefit of non-ML methods is that they are not a “black box” – one can readily implement them with basic programming and adjust rules as needed, without relying on a large framework or model.

## Comparative Effectiveness of Non-ML Methods
When comparing non-ML table detection approaches, we consider their accuracy (ability to correctly find tables) and their limitations. Key observations from literature and practice include:

- **Accuracy vs. Layout Complexity:** Simple methods like contiguous region detection work almost perfectly for sheets that are well-separated into rectangular tables with clear gaps. Their precision and recall drop when tables are **nested or adjacent** without clear separators ([TableSense: Spreadsheet Table Detection with Convolutional Neural Networks](https://www.microsoft.com/en-us/research/uploads/prod/2019/01/TableSense_AAAI19.pdf#:~:text=while%20region,are%20properly%20nor%02malized%20for%20automated)). In one evaluation on a diverse set of spreadsheets, Excel’s basic region-growing had barely ~55% precision in detecting table ranges ([](https://arxiv.org/pdf/2106.13500#:~:text=Region,CNN%2046.0%2041.4%2064.7%2065.3)), often merging separate tables or capturing extra cells. More elaborate heuristic systems (like RAC or Pytheas) boost accuracy significantly by handling those complex cases. For instance, RAC was shown to detect tables that simple rules missed, due to considering formatting and spatial graph structure ([Algorithms for Table Structure Recognition](https://ingenius.ups.edu.ec/index.php/ingenius/article/view/25.2021.05/4241#:~:text=The%20Remove%20and%20Conquer%20algorithm,between%20a%20proposed%20table%20P)). Pattern-based rules (Pytheas) reached **96%+ precision** on open data sets ([GitHub - cchristodoulaki/Pytheas: Pattern-based table discovery in Open Data CSV files](https://github.com/cchristodoulaki/Pytheas#:~:text=Australian%20portals,for%20accurately%20identifying%20potential%20errors)), indicating that with enough rules covering various patterns, non-ML methods can achieve **near-ML accuracy**. However, one should note that Pytheas did involve tuning and even an active learning component for its rules to generalize ([](http://www.vldb.org/pvldb/vol13/p2075-christodoulakis.pdf#:~:text=We%20observe%20that%20Pytheas%E2%80%99s%20confidence,some)) ([](http://www.vldb.org/pvldb/vol13/p2075-christodoulakis.pdf#:~:text=and%20header,4.5%20Runtime)) – so while it’s rule-based, it benefited from systematic optimization.

- **Robustness:** Rule-based algorithms might need adjustment for edge cases. For example, a heuristic might incorrectly split a single table if an internal styling quirk is misinterpreted as a separator. ML models, in theory, learn to handle such exceptions if seen in training; a heuristic approach needs explicit rules or conditions to handle them. Nonetheless, many real-world spreadsheets follow common layouts, and heuristics have proven quite robust for those. In cases of extremely unconventional layouts (say a sheet that is designed more like a dashboard with mixed content), both ML and non-ML struggle, but a human reviewing the output of a heuristic algorithm can at least trace why it made a mistake (e.g., “Oh, it thought this was two tables because of the blank column; maybe we should tweak the rule to require at least 2 blank columns for separation in this template”).

- **Maintenance and Adaptability:** A clear advantage of non-ML approaches is ease of maintenance. If the data characteristics change, you can modify or add a rule. For example, if you start encountering spreadsheets where tables are delineated by a specific color highlight rather than blank lines, you can incorporate a new rule to detect that color band as a separator. With an ML model, you would need to gather new training examples and retrain to adapt to such a change. On the flip side, crafting rules requires domain knowledge – one must foresee possible layouts. Non-ML methods might underperform if confronted with layouts not anticipated by the developers. In practice, combining clustering + a broad set of heuristics (drawn from the collective experience in literature) provides a strong baseline that covers most cases.

- **Metrics and Evaluation:** Various metrics have been used to compare methods: detecting all tables (table-level recall/precision), correctly identifying the exact range (boundary accuracy), etc. An interesting metric introduced in one study was *“Exact-or-Boundary (EoB)”* which gives partial credit if a detected range overlaps a true table range ([](https://arxiv.org/pdf/2106.13500#:~:text=match%20at%20L818%20one,Spreadsheet%20table%20detection%20on%20WebSheet400)) ([](https://arxiv.org/pdf/2106.13500#:~:text=Region,CNN%2046.0%2041.4%2064.7%2065.3)). Simple methods often get the general area right but might be off by a row or two (e.g., include a title in the table or miss the last row if it’s formatted differently). More rule-intensive methods improve boundary accuracy by catching those subtleties (like stopping at a double-ruled border line, or including a final total row if it’s part of the table logic). In evaluations on benchmarks like WebSheet (a collection of web-derived spreadsheets), non-ML baselines were often outperformed by carefully trained ML models in terms of exact boundary detection ([](https://arxiv.org/pdf/2106.13500#:~:text=one,Spreadsheet%20table%20detection%20on%20WebSheet400)). However, the gap is closing as heuristic methods incorporate more of the “knowledge” that the ML models learn. For many applications, having the table roughly identified (even if one extra blank cell is included) is sufficient; thus, a high-recall, moderate-precision heuristic might be preferable to a heavy ML solution, as long as it doesn’t miss tables entirely.

In conclusion, non-ML methods can be very effective and are often the method of choice when a quick, transparent solution is needed. They excel in scenarios with regular layouts or when we can enforce conventions in how tables are authored. Their performance in messy, unconstrained scenarios is improving, but one must be mindful of their rule boundaries. A combination of methods, or a hybrid approach (using heuristics first, and perhaps a lightweight ML verification second), can sometimes yield the best results – but if avoiding ML entirely, one can still achieve high performance by layering sufficient domain-driven rules.

## Recommendations
Based on the research and techniques surveyed, here are recommendations for designing an **efficient, accurate non-ML table detection system** for spreadsheets:

1. **Use a Hybrid of Clustering and Rules:** Start with a fast clustering step to identify candidate table regions (e.g., contiguous non-empty cell blocks separated by blank rows/columns) as this will cover the majority of straightforward cases. Then apply a comprehensive set of heuristic rules to refine those regions: confirm true tables, adjust boundaries (add or remove rows like headers or footers), and split or merge regions if the initial clustering was too coarse or too fine. This two-phase approach leverages the strength of clustering for speed and heuristics for accuracy.

2. **Incorporate Spreadsheet Metadata:** Take advantage of the rich metadata in spreadsheets – cell formatting, merged ranges, formulas, etc. These provide valuable signals. For instance, a merged range across several columns in top rows likely indicates a multi-span header; formula presence might indicate summary rows that often lie at the bottom of a table. Using these cues in rules can greatly improve accuracy with minimal performance cost (since metadata is readily accessible from file APIs). As noted in literature, algorithms using cell style and formatting information could detect tables that plain connectivity missed ([Algorithms for Table Structure Recognition](https://ingenius.ups.edu.ec/index.php/ingenius/article/view/25.2021.05/4241#:~:text=2.1.1.%20A%20Rule,top%2C%20bottom%2C%20left%2C%20and%20right)) ([](http://www.vldb.org/pvldb/vol13/p2075-christodoulakis.pdf#:~:text=Pytheas%20differs%20from%20existing%20approaches,On)).

3. **Prioritize High-Impact Heuristics:** Not all rules contribute equally. Focus on those that yield the biggest gains in identification. Studies show that enforcing column **type consistency** and proper header detection are among the most impactful heuristics for correctness ([](http://www.vldb.org/pvldb/vol13/p2075-christodoulakis.pdf#:~:text=%28see%20Table%203%29,49%20percentage%20points%20respec%02all%20rules)). Ensure your system reliably picks out header rows (via text vs. number patterns or formatting) and checks that below a header, columns do not break the expected pattern. These will catch many errors like accidentally merging two tables or cutting one table into pieces. If a particular domain has known patterns (e.g., every table has a "Year" column), include those in the rule set.

4. **Optimize for False Negatives:** In many applications, missing a table (false negative) is worse than having an extra range identified (false positive). Heuristic systems should be tuned to be conservative in splitting – err on the side of considering something one big table unless clearly divided. It’s easier for a post-processing step or a human to ignore an extra detected table or trim an extra row than to discover a table that was never detected. For example, if unsure whether an empty line is a separator or just spacing in a table, it might be safer to assume it’s spacing within one table and mark a single larger table. This maximizes recall. Rules can be crafted with this in mind (some systems allow a “strict” vs “loose” mode; in loose mode, they merge regions unless certain of a split).

5. **Test on Varied Samples:** Validate the detection on a wide range of spreadsheet styles – simple tables, pivot tables, financial reports with subtotals, forms, etc. This will reveal any patterns your rules don’t cover. You can then iteratively add heuristics for those. For instance, if you find that a report always has a summary row with bold text that your algorithm currently treats as a separate table, you might add a rule: “if a table range is immediately followed by a single bold row that has one cell matching a column name (like ‘Total’ under an Amount column), append it to the table as a footer.” Such fine-tuning ensures the method is robust before deployment.

6. **Leverage Open-Source as a Starting Point:** Given that Pytheas and other research code are available, consider using them as a foundation. Pytheas’s rules can potentially be extended to handle spreadsheet-specific features (since it was aimed at CSV). This could save development time and provide proven effectiveness out-of-the-box. If your context is not CSV but Excel, you’d integrate reading the Excel and then feeding a similar line-by-line analysis to the rule engine.

7. **Document and Modularize the Rules:** As the rule set grows, keep it maintainable. Organize rules into categories (layout-based, content-based, formatting-based). This modular approach means future updates or domain-specific adjustments can be made by enabling/disabling certain rule modules. It also aids transparency – you can explain the system’s logic to stakeholders by describing these modules. In environments where ML is not acceptable (for reasons of explainability or lack of training data), this clarity is a big advantage of your approach.

By following these recommendations, one can implement a **performance-optimized table detection system** that forgoes machine learning yet capably identifies tables in spreadsheets. Such a system will be fast, require no training data, and be adaptable as new spreadsheet patterns emerge. The key is to combine the speed of clustering with the insight of well-chosen heuristics, yielding a solution that is both **efficient and reliable** for real-world use.

**Sources:**

1. Doush, I. A., & Pontelli, E. (2010). *Detecting and recognizing tables in spreadsheets.* Proceedings of the 9th IAPR International Workshop on Document Analysis Systems – rule-based approach for spreadsheet table detection ([Detecting and recognizing tables in spreadsheets - ResearchGate](https://www.researchgate.net/publication/220932993_Detecting_and_recognizing_tables_in_spreadsheets#:~:text=ResearchGate%20www,still%20a%20big%20gap)).

2. Koci, E., et al. (2018). *Table recognition in spreadsheets via a graph representation.* 13th IAPR DAS – “Remove and Conquer” algorithm using graph-based rules for table identification ([Algorithms for Table Structure Recognition](https://ingenius.ups.edu.ec/index.php/ingenius/article/view/25.2021.05/4241#:~:text=2,direction%20of%20the%20graph%20that)) ([[2211.08469] Deep learning for table detection and structure recognition: A survey](https://ar5iv.labs.arxiv.org/html/2211.08469#:~:text=E%20Koci%20,set%20of%20carefully%20selected%20criteria)).

3. Escalona, Y., et al. (2021). *Algorithms for Table Structure Recognition.* Ingenius, No.25 – describes region detection in spreadsheets using formatting and empty row/col separators ([Algorithms for Table Structure Recognition](https://ingenius.ups.edu.ec/index.php/ingenius/article/view/25.2021.05/4241#:~:text=Region%20detection%20consists%20in%20scanning,maximal%20collection%20R%20%E2%8A%86%20W)) and graph-based RAC method ([Algorithms for Table Structure Recognition](https://ingenius.ups.edu.ec/index.php/ingenius/article/view/25.2021.05/4241#:~:text=2,direction%20of%20the%20graph%20that)).

4. Chen, Z., & Cafarella, M. (2013). *Automatic web spreadsheet data extraction.* In Proc. 22nd WWW (Companion) – used Conditional Random Fields for spreadsheet table detection (ML approach) ([](http://www.vldb.org/pvldb/vol13/p2075-christodoulakis.pdf#:~:text=components%20of%20tabular%20data%20from,24%2C%2054)).

5. Christodoulakis, C., et al. (2020). *Pytheas: Pattern-based Table Discovery in CSV Files.* PVLDB 13(11) – fuzzy rule-based table detection achieving ~96% precision/recall ([GitHub - cchristodoulaki/Pytheas: Pattern-based table discovery in Open Data CSV files](https://github.com/cchristodoulaki/Pytheas#:~:text=Australian%20portals,for%20accurately%20identifying%20potential%20errors)); open-source implementation ([GitHub - cchristodoulaki/Pytheas: Pattern-based table discovery in Open Data CSV files](https://github.com/cchristodoulaki/Pytheas#:~:text=Pytheas%3A%20Pattern,CSV%20Files)).

6. Luo, X., et al. (2019). *TableSense: Spreadsheet Table Detection with Convolutional Neural Networks.* AAAI – (for context) notes fragility of Excel’s region-growth on complicated layouts ([TableSense: Spreadsheet Table Detection with Convolutional Neural Networks](https://www.microsoft.com/en-us/research/uploads/prod/2019/01/TableSense_AAAI19.pdf#:~:text=while%20region,are%20properly%20nor%02malized%20for%20automated)) and compares non-ML baselines ([](https://arxiv.org/pdf/2106.13500#:~:text=one,Spreadsheet%20table%20detection%20on%20WebSheet400)).

7. Heuristic extraction algorithm (2021). *Int. J. of Advanced Computer Science and Applications, 12(10).* – outlines steps to detect multiple tables in one sheet using empty row/column “synchronization” ([Heuristic Algorithm for Automatic Extraction Relational Data from Spreadsheet Hierarchical Tables](https://thesai.org/Downloads/Volume12No10/Paper_82-Heuristic_Algorithm_for_Automatic_Extraction_Relational_Data.pdf#:~:text=B,filled%20data%20columns%2C%20that%20means)) ([Heuristic Algorithm for Automatic Extraction Relational Data from Spreadsheet Hierarchical Tables](https://thesai.org/Downloads/Volume12No10/Paper_82-Heuristic_Algorithm_for_Automatic_Extraction_Relational_Data.pdf#:~:text=V,to%20explore%20the%20new%20one)) and rules for headers/attributes ([Heuristic Algorithm for Automatic Extraction Relational Data from Spreadsheet Hierarchical Tables](https://thesai.org/Downloads/Volume12No10/Paper_82-Heuristic_Algorithm_for_Automatic_Extraction_Relational_Data.pdf#:~:text=heuristic%20rules%20and%20cell%20features,Extract%20Table%20Name)).

8. Escalona, Y. (2021). *Master’s Thesis: Table Structure Recognition in Spreadsheets.* – further details on RAC and table element classification (headers, data, metadata) ([Algorithms for Table Structure Recognition](https://ingenius.ups.edu.ec/index.php/ingenius/article/view/25.2021.05/4241#:~:text=It%20also%20is%20inferred%20the,En%02cabezado%2C%20Datos%2C%20T%C3%ADtulo)) ([Algorithms for Table Structure Recognition](https://ingenius.ups.edu.ec/index.php/ingenius/article/view/25.2021.05/4241#:~:text=%29%206%3D%201,column%2C%20and%20maximum%20column%20match)).

