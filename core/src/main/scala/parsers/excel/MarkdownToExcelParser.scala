package com.tjclp.xlcr
package parsers.excel

import models.Content
import types.MimeType
import org.apache.poi.ss.usermodel._
import org.apache.poi.xssf.usermodel.XSSFWorkbook
import org.slf4j.LoggerFactory
import parsers.Parser

import java.io.FileOutputStream
import java.nio.charset.StandardCharsets
import java.nio.file.{Files, Path}
import scala.collection.mutable
import scala.util.{Failure, Success, Try, Using}

/**
 * MarkdownToExcelParser reconstructs an Excel workbook from a Markdown
 * string that was generated by ExcelMarkdownParser. The typical format
 * includes multiple sheets separated by headings (# SheetName),
 * and for each sheet, a table listing row/column, etc.
 *
 * We split out helper methods to parse the data, separate in-memory logic,
 * and handle potential malformed input with standard errors.
 */
object MarkdownToExcelParser extends Parser:
  private val logger = LoggerFactory.getLogger(getClass)

  override def extractContent(input: Path, output: Option[Path] = None): Try[Content] = {
    // 1) Read the entire markdown file (I/O)
    val markdownTry = readMarkdownFile(input)
    //if markdownTry.isFailure then return markdownTry.mapFailure

    // 2) Transform markdown -> workbook (in-memory)
    val workbookTry = markdownTry.flatMap(md => parseMarkdownToWorkbook(md))
    //if workbookTry.isFailure then return workbookTry.mapFailure

    // 3) Write workbook to output if provided, else store in temp
    val outPathTry = workbookTry.flatMap { workbook =>
      val out = output.getOrElse(Files.createTempFile("xlcr_markdown_to_excel", ".xlsx"))
      val writeResult = writeWorkbook(workbook, out)
      // Close workbook no matter what
      workbook.close()
      writeResult.map(_ => out)
    }

    // 4) Convert to bytes and optionally delete temp
    outPathTry.map { outPath =>
      val bytes = Files.readAllBytes(outPath)
      if output.isEmpty then Files.deleteIfExists(outPath)

      Content(
        data = bytes,
        contentType = outputType.mimeType,
        metadata = Map("Description" -> "Converted from Markdown to Excel")
      )
    }
  }

  override def outputType: MimeType = MimeType.ApplicationVndOpenXmlFormatsSpreadsheetmlSheet
  override def supportedInputTypes: Set[MimeType] = Set(MimeType.TextMarkdown)
  override def priority: Int = 5

  /** Reads entire Markdown file into a string. */
  private def readMarkdownFile(path: Path): Try[String] =
    Try {
      if !Files.exists(path) then
        throw new IllegalArgumentException(s"Markdown file does not exist: $path")
      new String(Files.readAllBytes(path), StandardCharsets.UTF_8)
    }

  /** Writes workbook to a given path. */
  private def writeWorkbook(workbook: XSSFWorkbook, outPath: Path): Try[Unit] =
    Try {
      Using.resource(new FileOutputStream(outPath.toFile)) { fos =>
        workbook.write(fos)
      }
    }

  /**
   * High-level method that parses markdown string into an in-memory XSSFWorkbook.
   * We handle multi-sheet logic, extracting sheet blocks, then parsing table data.
   */
  private def parseMarkdownToWorkbook(md: String): Try[XSSFWorkbook] = Try {
    val lines = md.linesIterator.toList
    val workbook = new XSSFWorkbook()
    val sheetBlocks = splitSheets(lines)

    sheetBlocks.foreach { case (sheetName, contentLines) =>
      val sheet = workbook.createSheet(sheetName)
      parseTableIntoSheet(contentLines, sheet)
    }

    workbook
  }

  /**
   * Identify sheet blocks by lines starting with "# ".
   * Returns a sequence of (sheetName, linesForThatSheet).
   */
  private def splitSheets(lines: List[String]): List[(String, List[String])] =
    val result = mutable.ListBuffer.empty[(String, List[String])]
    var currentSheetName = "Sheet1"
    var currentBlock = mutable.ListBuffer.empty[String]
    var firstSheet = true

    def pushBlock(): Unit =
      if currentBlock.nonEmpty then
        result += ((currentSheetName, currentBlock.toList))
        currentBlock.clear()

    for line <- lines do
      if line.trim.startsWith("# ") then
        if !firstSheet then pushBlock()
        else firstSheet = false
        currentSheetName = line.trim.stripPrefix("# ").trim
      else
        currentBlock += line

    if currentBlock.nonEmpty then pushBlock()
    result.toList

  /**
   * Parse a table of rows into the given sheet.
   * We skip the header row, then process each line's row number and cell content.
   */
  private def parseTableIntoSheet(lines: List[String], sheet: Sheet): Unit =
    // Filter lines that start with '|'
    val dataLines = lines.filter(_.trim.startsWith("|"))
    if dataLines.size < 2 then return

    // First line => header columns
    val headerCols = parseMarkdownRow(dataLines.head)
    // discard the first column (row/column label)
    val colHeaders = headerCols.drop(1)

    // Remaining lines => skip any table separator
    val contentLines = dataLines.tail.filterNot(_.matches("""\|\s*-*:?\|\s*.*"""))
    for (i <- contentLines.indices) do
      val rowStr = contentLines(i)
      val cells = parseMarkdownRow(rowStr)
      if cells.nonEmpty then
        // Attempt to parse rowNumber from the first column
        val rowNumberString = cells.head.trim
        val rowIndex = rowNumberString.toIntOption.getOrElse(i) - 1
        if rowIndex >= 0 then
          val rowObj = sheet.createRow(rowIndex)
          for colIndex <- colHeaders.indices do
            val value = if colIndex + 1 < cells.size then cells(colIndex + 1).trim else ""
            val cleanedValue = extractValueFromCellMarkdown(value)
            val cellType = determineCellType(value, cleanedValue)
            val cellObj = rowObj.createCell(colIndex, cellType)

            cellType match
              case CellType.NUMERIC => 
                cellObj.setCellValue(cleanedValue.toDoubleOption.getOrElse(0.0))
              case CellType.BOOLEAN =>
                cellObj.setCellValue(cleanedValue.toBooleanOption.getOrElse(false))
              case CellType.FORMULA =>
                cellObj.setCellFormula(cleanedValue)
              case CellType.BLANK =>
                // do nothing
              case _ =>
                cellObj.setCellValue(cleanedValue)

  /** Helper to parse a single markdown row, splitting on '|' */
  private def parseMarkdownRow(line: String): List[String] =
    val trimmed = line.trim.stripPrefix("|").stripSuffix("|").trim
    trimmed.split("\\|").map(_.trim).toList

  /**
   * Extract the main data from a cell text, e.g. "VALUE:``Hello``<br>TYPE:``STRING``"
   * We'll look for "VALUE:``(...)``" pattern.
   */
  private def extractValueFromCellMarkdown(mdCell: String): String =
    val valueRegex = """(?s).*?VALUE:``(.*?)``.*""".r
    mdCell match
      case valueRegex(captured) => captured
      case _ => mdCell

  /**
   * Determine final CellType based on explicit TYPE:``...`` or autodetect numeric/boolean.
   */
  private def determineCellType(fullValue: String, cleanedValue: String): CellType =
    val typeRegex = """(?s).*?TYPE:``(.*?)``.*""".r
    val explicitTypeOpt = fullValue match
      case typeRegex(t) => Some(t)
      case _ => None

    explicitTypeOpt match
      case Some("NUMERIC") => CellType.NUMERIC
      case Some("BOOLEAN") => CellType.BOOLEAN
      case Some("FORMULA") => CellType.FORMULA
      case Some("BLANK")   => CellType.BLANK
      case Some(_)         => CellType.STRING
      case None =>
        if cleanedValue.matches("""-?\d+(\.\d+)?""") then CellType.NUMERIC
        else if cleanedValue.equalsIgnoreCase("true") || cleanedValue.equalsIgnoreCase("false") then CellType.BOOLEAN
        else if cleanedValue.isEmpty then CellType.BLANK
        else CellType.STRING

  /** Convert a Failure to a standard Failure type for clarity. */
  private implicit class TryOps[T](val t: Try[T]) extends AnyVal:
    def mapFailure: Try[T] = t.recoverWith { case ex =>
      Failure(new RuntimeException(s"MarkdownToExcelParser failed: ${ex.getMessage}", ex))
    }